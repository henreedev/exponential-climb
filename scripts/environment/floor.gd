extends Node2D

## Manages the rooms generated on a given floor. 
class_name Floor

signal new_room_generated

## Used to sequence generating the first, then second room.
signal current_room_set

const ROOM_SCENE = preload("res://scenes/environment/room.tscn")

@onready var room_seed_label : Label = get_tree().get_first_node_in_group("roomseed")
## The room currently being played by the Player.
var current_room: Room
## The room the Player will enter after the current room.
## Pre-generated by RoomGenerator at game start and upon swapping levels. 
## NOTE: This could cause lag during the start of the next room
var next_room: Room
## The seed to use when generating the next room.
var next_room_seed: int = -1

func _ready():
	seed(1)
	Global.current_floor = self
	await get_tree().process_frame # TODO why do this
	
	generate_first_two_rooms()

## Called at game start to generate the very first two rooms. 
## Afterwards, the next room should always be on-deck.
func generate_first_two_rooms():
	RoomGenerator.room_generated.connect(set_current_room_and_disconnect)
	RoomGenerator.generate_new_room_in_bg.call_deferred()
	await current_room_set # TODO can remove here i think


func set_current_room_and_disconnect(room: Room): # TODO rename
	next_room = room
	swap_to_next_room()
	disconnect_room_generated_signal(set_current_room_and_disconnect)
	
	current_room_set.emit()

func pregenerate_next_room():
	assert(next_room == null)
	assert(not RoomGenerator.is_generating_room())
	RoomGenerator.room_generated.connect(set_next_room_and_disconnect)
	RoomGenerator.generate_new_room_in_bg.call_deferred()

func set_next_room_and_disconnect(room: Room):
	next_room = room
	disconnect_room_generated_signal(set_next_room_and_disconnect)

func disconnect_room_generated_signal(from_method: Callable):
	assert(RoomGenerator.room_generated.is_connected(from_method))
	RoomGenerator.room_generated.disconnect(from_method)

func _input(event):
	if event.is_action_pressed("test_generate_same_room"):
		assert(false) # TODO
	if event.is_action_pressed("test_generate_new_room"):
		swap_to_next_room()

func swap_to_next_room():
	if RoomGenerator.is_generating_room():
		print("Can't swap rooms yet, RoomGenerator is still working on the next room")
		return
	# Remove previous room
	remove_children()
	# Let noise visualization know there's been a new room created.
	new_room_generated.emit()
	
	for enemy in get_tree().get_nodes_in_group("enemy"):
		enemy.queue_free()
	
	assert(next_room)
	current_room = next_room
	add_child.call_deferred(current_room)
	
	next_room = null
	pregenerate_next_room()
	
	Global.player.global_position = Vector2.ZERO
	
#
#func generate_new_room(start_pos := Vector2.ZERO, seed := -1):
	## Pick a new seed and display it 
	#var new_seed = seed if seed != -1 else randi()
	#seed(new_seed)
	#room_seed = new_seed
	#
	#room_seed_label.text = str(room_seed)
	#print("Room seed: ", room_seed)
	#
	## Remove previous room
	#remove_children()
	#
	#for enemy in get_tree().get_nodes_in_group("enemy"):
		#enemy.queue_free()
	#
	## Create the new room, timing how long it takes and printing it
	#print("Starting room generation")
	#var time = Time.get_ticks_msec()
	#current_room = await Room.generate_room(start_pos, self, new_seed)
	#print("Room created in ", Time.get_ticks_msec() - time, "ms")
	#
	## Let noise visualization know there's been a new room created.
	#new_room_generated.emit()
#
	## Create the pathfinding graph for this room, timing it
	#print("Starting pathfinding")
	#time = Time.get_ticks_msec()
	#Pathfinding.update_graph()
	#print("Pathfinding graph created in ", Time.get_ticks_msec() - time, "ms")

func remove_children():
	while get_child_count() >= 1: 
		get_child(0).queue_free() 
		remove_child(get_child(0))
